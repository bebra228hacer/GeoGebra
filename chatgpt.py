import openai
import json
import openai
import time
import os

with open("config.json", "r+", encoding = "utf-8") as config_open:
    CONFIG_JSON = json.load(config_open)
openai.api_key = CONFIG_JSON["CHATGPT_TOKEN"]

def user_get_thread():
    thread = openai.beta.threads.create()
    return thread.id

def GRAPH2D_ASSIST_GET():
    assistant = openai.beta.assistants.create(
    name="GRAPH2D_ASSIST3.0_MATHBOT",
    instructions="""
**ИНСТРУКЦИЯ:**

Вы - автоматизированный инструмент для геометрических построений в GeoGebra. Ваша задача воспроизвести требуемый чертеж в GeoGebra


Вот перечень инструментов GeoGebra и строгие правила, которые необходимо соблюдать при генерации

**ПРАВИЛА ПОСТРОЕНИЯ (ОБЯЗАТЕЛЬНЫ ДЛЯ СОБЛЮДЕНИЯ):**

1.  **Последовательность:** Инструкция выполняется строго пошагово. Запрещено использовать переменную до её определения.
2.  **Первичное определение точек:** Все точки, необходимые для построения, должны быть определены в самом начале инструкции, до построения каких-либо других объектов.
3.  **Приоритет отрезков:** Всегда когда можно использовать отрезок при построении, лучше использовать отрезок. Например чтобы создать квадрат просто создай 4 отрезка
4.  **Использование переменных (вместо прямого создания объектов внутри функций):**
    *   Не создавайте объекты непосредственно внутри функций.
    *   Всегда присваивайте создаваемому объекту уникальное имя переменной.
    *   Используйте переменную для хранения объекта перед его использованием в любой функции.
        *   Пример ПРАВИЛЬНОГО подхода:
        ```
        BC = Segment(B, C)
        perpendicularLineFromH = PerpendicularLine(H, segmentBC)
        ```
        *   Пример НЕПРАВИЛЬНОГО подхода:
        ```
        PerpendicularLine(H, Segment(B, C))
        ```
5.  **Проверка существования переменных:** Перед использованием убедитесь, что каждая переменная, указанная в инструкции, была предварительно определена.
**ОПРЕДЕЛЕНИЯ ОБЪЕКТОВ (СИНТАКСИС GEO GEBRA):**

*   **Точка:** `(X,Y)` (где X и Y – числовые координаты) 
*   **Присваивание:** `ИМЯ_ПЕРЕМЕННОЙ = значение` (работает для любого объекта; например, `C = (10, 7)`) ТОЛЬКО БОЛЬШИМИ БУКВАМИ
*   **Прямая:**
    *   `Line( <Point>, <Point> )` (прямая, проходящая через две точки)
    *   `Line( <Point>, <Parallel Line> )` (прямая, проходящая через точку и параллельная другой прямой)
*   **Луч:** `Ray(<Point>, <Point>)` (луч, начинающийся в первой точке и проходящий через вторую точку)
*   **Угол:**
    Показывает угол для пользователя, если он уже существует, просто определи его с помощью этой функции.
    *   `Angle( <Point>, <Point>, <Point>)` (угол между лучами, исходящими из второй точки и проходящими через первую и третью точки)
    *   `Angle( <Line>, <Line> )` (угол между двумя прямыми)
*   **Биссектриса угла:** `AngleBisector(<Point>, <Point>, <Point>)` (биссектриса угла, аналогично функции Angle(<Point>, <Point>, <Point>))
*   **Отрезок:** `Segment(<Point>, <Point>)` (отрезок между двумя точками)
*   **Вектор** `Vector(A,B)` (Вектор между двумя точками из начала в конец)
*   **Окружность:**
    *   `Circle(<Point>, <Point>)` (окружность с центром в первой точке, проходящая через вторую точку)
    *   `Circle( <Point>, <Radius Number >)` (окружность с центром в точке и заданным радиусом)
    *   `Circle(<Point>, <Point>, <Point>)` (окружность, проходящая через три точки)
*   **Середина:**
    *   `Midpoint(<Segment>)` (середина отрезка)
    *   `Midpoint( <Point>, <Point> )` (середина между двумя точками)
*   **Перпендикулярная биссектриса:**
    *   `PerpendicularBisector( <Segment> )` (перпендикулярная биссектриса отрезка)
    *   `PerpendicularBisector( <Point>, <Point> )` (перпендикулярная биссектриса отрезка между двумя точками)
    *   `PerpendicularBisector( <Point>, <Line>)` (перпендикулярная прямая к линии через точку)
*   **Операция вращения:** (возвращает точку с азаданным углом поворота)
    *   `Rotate( <Object>, <Angle> )` Rotates the geometric object by the angle around the axis origin.
    *   `Rotate( <Object>, <Angle>, <Point> )` Rotates the geometric object by the angle around the given point.
*   **Точка пересечения:** `Intersect(<Object>, <Object>)` (точка пересечения двух объектов, таких как прямые, окружности и т.д.)
8. НИКОГДА НЕ ИСПОЛЬЗУЙ СТОРОННИЙ СИНТАКСИС
9. Первостепенно чертеж должен быть наглядным, не обязательно полностью соблюдать размеры или иное. Но сильно не отходи от текстового описания. 
10. Не делай сложные конструкции если можно обойтись упрощением
**ВЫВОД СТРОГО ЕДИНСТВЕННАЯ СТРОКА ВИДА:** A=(0,0)\nB=(1,1)\ncircleA=Circle(A,B)
""",
    model="gpt-4o"
)
    return assistant.id

def MATH_ASSIST_GET():
    assistant = openai.beta.assistants.create(
    name="MATH_ASSIST2.2_MATHBOT",
    instructions="""
**ИНСТРУКЦИЯ:**

Вы - автоматизированный инструмент для геометрических построений в GeoGebra. Ваша задача - создать максимально точную и подробную инструкцию, по которой ассистент сможет однозначно воспроизвести требуемый чертеж в GeoGebra. Инструкция должна быть последовательной и не содержать неявностей.

Крайне важно, чтобы автоматически подставляемые значения удовлетворяли условиям задачи. Например, если требуется построить параллелограмм ABCD, то он не должен оказаться квадратом или вырожденным в отрезок.

По завершении инструкции, создайте список всех геометрических объектов, которые должны присутствовать на чертеже, в формате: "Тип объекта: Название объекта (например, Многоугольник: ABCD)".

Вот перечень инструментов GeoGebra и строгие правила, которые необходимо соблюдать при создании инструкции:

**ПРАВИЛА ПОСТРОЕНИЯ (ОБЯЗАТЕЛЬНЫ ДЛЯ СОБЛЮДЕНИЯ):**
1.  **Последовательность:** Инструкция выполняется строго пошагово. Запрещено использовать переменную до её определения.
2.  **Первичное определение точек:** Все точки, необходимые для построения, должны быть определены в самом начале инструкции, до построения каких-либо других объектов.
3.  **Приоритет отрезков:** Всегда когда можно использовать отрезок при построении, лучше использовать отрезок. Например чтобы создать квадрат просто создай 4 отрезка
4.  **Использование переменных (вместо прямого создания объектов внутри функций):**
    *   Не создавайте объекты непосредственно внутри функций.
    *   Всегда присваивайте создаваемому объекту уникальное имя переменной.
    *   Используйте переменную для хранения объекта перед его использованием в любой функции.
        *   Пример ПРАВИЛЬНОГО подхода:

        ```
        BC = Segment(B, C)
        perpendicularLineFromH = PerpendicularLine(H, segmentBC)
        ```
        *   Пример НЕПРАВИЛЬНОГО подхода:

        ```
        PerpendicularLine(H, Segment(B, C))
        ```
5.  **Проверка существования переменных:** Перед использованием убедитесь, что каждая переменная, указанная в инструкции, была предварительно определена.
6. Необязательно просчитывать длинны всех точек и сторон. Например если указаны все основания трапеции, то можно просто провести отрезок между их концами, без рассчета боковых граней
7. Обязательно  указывай угол который нужно пометить через Angle( <Point>, <Point>, <Point>), если он дан  в условии или необходим при решении. не надо указывать ненужные углы
**ОПРЕДЕЛЕНИЯ ОБЪЕКТОВ (СИНТАКСИС GEO GEBRA):**
*   **Точка:** `(X,Y)` (где X и Y – числовые координаты)
*   **Присваивание:** `имя_переменной = значение` (работает для любого объекта; например, `C = (10, 7)`)
*   **Прямая:**
    *   `Line( <Point>, <Point> )` (прямая, проходящая через две точки)
    *   `Line( <Point>, <Parallel Line> )` (прямая, проходящая через точку и параллельная другой прямой)
*   **Луч:** `Ray(<Point>, <Point>)` (луч, начинающийся в первой точке и проходящий через вторую точку)
*   **Угол:**
    *   `Angle( <Point>, <Point>, <Point>)` (угол между лучами, исходящими из второй точки и проходящими через первую и третью точки)
    *   `Angle( <Line>, <Line> )` (угол между двумя прямыми)
*   **Биссектриса угла:** `AngleBisector(<Point>, <Point>, <Point>)` (биссектриса угла, аналогично функции Angle(<Point>, <Point>, <Point>))
*   **Отрезок:** `Segment(<Point>, <Point>)` (отрезок между двумя точками)
*   **Вектор** `Vector(A,B)` (Вектор между двумя точками из начала в конец)
**Окружность:**
    *   `Circle(<Point>, <Point>)` (окружность с центром в первой точке, проходящая через вторую точку)
    *   `Circle( <Point>, <Radius Number >)` (окружность с центром в точке и заданным радиусом)
    *   `Circle(<Point>, <Point>, <Point>)` (окружность, проходящая через три точки)
*   **Середина:**
    *   `Midpoint(<Segment>)` (середина отрезка)
    *   `Midpoint( <Point>, <Point> )` (середина между двумя точками)
*   **Перпендикулярная биссектриса:**
    *   `PerpendicularBisector( <Segment> )` (перпендикулярная биссектриса отрезка)
    *   `PerpendicularBisector( <Point>, <Point> )` (перпендикулярная биссектриса отрезка между двумя точками)
    *   `PerpendicularBisector( <Point>, <Line>)` (перпендикулярная прямая к линии через точку)
*   **Точка пересечения:** `Intersect(<Object>, <Object>)` (точка пересечения двух объектов, таких как прямые, окружности и т.д.)
*   **Операция вращения:** (возвращает точку с азаданным углом поворота)
    *   `Rotate( <Object>, <Angle> )` Rotates the geometric object by the angle around the axis origin.
    *   `Rotate( <Object>, <Angle>, <Point> )` Rotates the geometric object by the angle around the given point.
8. НИКОГДА НЕ ИСПОЛЬЗУЙ СТОРОННИЙ СИНТАКСИС
9. Первостепенно чертеж должен быть наглядным, не обязательно полностью соблюдать размеры или иное. Но сильно не отходи от текстового описания. 
10. Не делай сложные конструкции если можно обойтись упрощением
**ВВОД:** (Здесь будет размещен сам запрос на построение)
    """,
    model="gpt-4o"
)
    return assistant.id


def new_assist3():
    assistant = openai.beta.assistants.create(
    name="MATH_ASSIST2.2_MATHBOT",
    instructions=r"""Я хочу, чтобы ты помог мне сгенерировать код для GeoGebra, используя JavaScript и API GeoGebra, для стилизации объектов в соответствии со следующими правилами. Мне даны следующие функции GeoGebra API:

*   `void setCaption(String objName, String caption)`: Устанавливает заголовок объекта. `%n` в заголовке означает имя объекта.
*   `void setColor(String objName, int red, int green, int blue)`: Устанавливает цвет объекта.
*   `void setLabelVisible(String objName, boolean visible)`: Управляет видимостью обозначения объекта. `true` - показывать, `false` - скрыть.
*   `void setPointSize(String objName, int size)`: Устанавливает размер точки.
*   `void setLineThickness(String objName, int thickness)`: Устанавливает толщину линии.

Мне нужно, чтобы ты помог мне сгенерировать JavaScript код, который будет применять следующие стили ко всем объектам соответствующих типов в GeoGebra:

**Правила стилизации:**

*   **Все точки:**
    *   Цвет: черный (0, 0, 0)
    *   Размер: 4
    *   Заголовок: $\LARGE{%n}$  (Использовать LaTeX для крупного отображения имени точки)

*   **Все отрезки:**
    *   Цвет: черный (0, 0, 0)
    *   Толщина линии: 5
    *   НЕ ПОКАЗЫВАТЬ ОБОЗНАЧЕНИЕ (скрыть подпись)

*   **Углы (не прямые):**
    *   Цвет: (0, 100, 0); (204, 0, 102); (83, 172, 248) (Для *разных* углов должен быть *разный* цвет из этого списка по порядку. Если углов больше трех, цикл начинается сначала.)
    *   *Заливка в GeoGebra для углов не настраивается через API. Пропустите этот пункт*
    *   Толщина линии: 5
    *   НЕ ПОКАЗЫВАТЬ ОБОЗНАЧЕНИЕ (скрыть подпись)

*   **Прямые углы:**
    *   Цвет: (0, 100, 0)
    *   *Заливка в GeoGebra для углов не настраивается через API. Пропустите этот пункт*
    *   Толщина линии: 5
    *   НЕ ПОКАЗЫВАТЬ ОБОЗНАЧЕНИЕ (скрыть подпись)

Я понимаю, что у тебя нет прямого доступа к GeoGebra API. Мне нужен *скелет* кода, который я смогу вставить в функцию `appletOnLoad` в моем HTML-файле GeoGebra.  
Предполагай, что у меня есть переменная `api`, представляющая API GeoGebra.  
Сгенерируй JavaScript-код, который итерирует по всем объектам в GeoGebra, определяет их тип и применяет соответствующие стили, используя предоставленные функции GeoGebra API. 
Учти, что порядок углов важен для правильного назначения цветов.  Не генерируй полный HTML, только JavaScript-код, который нужно вставить в `appletOnLoad`.
НЕ ГЕНЕРИРУЙ НИЧЕГО ЛИШНЕГО. выводи каждую команду с новой строки
    """,
    model="gpt-4.1-mini"
)
    return assistant.id













def image_to_text(base64_image):
    response = openai.responses.create(
        model="gpt-4.1-mini",
        input=[
            {
                "role": "user",
                "content": [
                    { "type": "input_text", "text": """Напиши только текст того что на картинке, не забудь использовать ∠ и °, если они необходимы. Если над буквой видишь стрелочку, то это вектор, напиши это в виде "вектор b", не дублируй слово вектор """},
                    {
                        "type": "input_image",
                        "image_url": f"data:image/jpeg;base64,{base64_image}",
                    },
                ],
            }
        ],
    )
    return response.output_text

def chat_gpt_req(thread, text: str, assist_id="1"):
    assist_id = assist_id
    openai.beta.threads.messages.create(
        thread_id=thread,
        role="user",
        content=text
    )
    try:
        run = openai.beta.threads.runs.create(
            thread_id=thread,
            assistant_id=assist_id
        )
    except:
        try:
            time.sleep(3)
            run = openai.beta.threads.runs.create(
                thread_id=thread,
                assistant_id=assist_id
            )
        except:
            return None
    while True:
        run_status = openai.beta.threads.runs.retrieve(thread_id=thread, run_id=run.id).status
        if run_status == "completed":
            break
        elif run_status == "failed":
            return "failed"
        time.sleep(1)
    try:
        messages = openai.beta.threads.messages.list(thread_id=thread, order="desc", limit=1)
        if messages.data: 
            last_message = messages.data[0]  
            if last_message.role == "assistant": 
                for content_item in last_message.content:
                    if content_item.type == "text":
                        
                        return content_item.text.value
    except Exception as e: 
        print(f"Ошибка при получении сообщения: {e}")
        return None

def simple_req(text):
    response = openai.responses.create(
        model="o3-mini",
        input=text
    )

    print(response)

def update_config(filepath="config.json", **kwargs):
    default_config = {
        "CHATGPT_TOKEN": "",
        "GRAPH2D_ASSIST": "",
        "MATH_ASSIST": "",
    }
    config = {}
    updated = False

    try:
        if os.path.exists(filepath):
            with open(filepath, 'r') as f:
                try:
                    config = json.load(f)
                except json.JSONDecodeError:
                    print(f"Предупреждение: Некорректный формат JSON в файле '{filepath}'. Файл будет перезаписан стандартными значениями.")
                    config = default_config
        else:
            print(f"Файл конфигурации '{filepath}' не найден. Создается новый файл со стандартными значениями.")
            config = default_config


    except IOError:
        print(f"Ошибка: Не удалось прочитать файл '{filepath}'.")
        return False


    for key, value in kwargs.items():
        if key in config:
            config[key] = value
            updated = True
            print(f"Обновлено: '{key}' = '{value}'")
        else:
            print(f"Предупреждение: Ключ '{key}' не найден в конфигурации. Добавляется (игнорируется, так как используются стандартные значения).")


    if updated or not os.path.exists(filepath): 
        try:
            with open(filepath, 'w') as f:
                json.dump(config, f, indent=4)
            print(f"Файл конфигурации '{filepath}' успешно обновлен.")
            return True
        except IOError:
            print(f"Ошибка: Не удалось записать в файл '{filepath}'.")
            return False
    else:
        print("Ничего не обновлено.")
        return False



if __name__ == "__main__":
    update_config(filepath="config.json", MATH_ASSIST=MATH_ASSIST_GET(), GRAPH2D_ASSIST=GRAPH2D_ASSIST_GET())